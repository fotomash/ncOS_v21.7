import os
from pydantic import BaseSettings, AnyHttpUrl
from pydantic import validator

class Settings(BaseSettings):
    """
    Application configuration driven by environment variables.
    Supports API key, CORS, OpenAPI metadata, observability, and OAuth2/JWT settings.
    """
    # Core
    APP_NAME: str = os.getenv("APP_NAME", "CopilotFramework")
    ENV: str = os.getenv("ENV", "development")
    
    # Security
    API_KEY_HEADER: str = os.getenv("API_KEY_HEADER", "X-API-Key")
    VALID_API_KEYS: list[str] = os.getenv("VALID_API_KEYS", "").split(",")

    # Paths
    MODULES_PATH: str = os.getenv("MODULES_PATH", "modules")
    DOCS_PATH: str = os.getenv("DOCS_PATH", "docs")
    MKDOCS_CONFIG_PATH: str = os.getenv("MKDOCS_CONFIG_PATH", "mkdocs.yml")

    # CORS
    DEV_CORS_ORIGINS: list[AnyHttpUrl] = os.getenv("DEV_CORS_ORIGINS", "http://localhost:3000").split(",")
    PROD_CORS_ORIGINS: list[AnyHttpUrl] = os.getenv("CORS_ORIGINS", "").split(",")
    CORS_ORIGINS: list[AnyHttpUrl] = DEV_CORS_ORIGINS if ENV.lower() == "development" else PROD_CORS_ORIGINS

    # OpenAPI Metadata
    TITLE: str = os.getenv("OPENAPI_TITLE", APP_NAME)
    VERSION: str = os.getenv("OPENAPI_VERSION", "0.1.0")
    DESCRIPTION: str = os.getenv("OPENAPI_DESCRIPTION", "Generated by Zanzibar Structured Intelligence Framework")

    # Observability
    ENABLE_PROMETHEUS: bool = os.getenv("ENABLE_PROMETHEUS", "false").lower() == "true"
    ENABLE_OTEL: bool = os.getenv("ENABLE_OTEL", "false").lower() == "true"
    OTEL_SERVICE_NAME: str = os.getenv("OTEL_SERVICE_NAME", APP_NAME)

    # OAuth2 / JWT configuration
    OAUTH2_CLIENT_ID: str | None = os.getenv("OAUTH2_CLIENT_ID")
    OAUTH2_CLIENT_SECRET: str | None = os.getenv("OAUTH2_CLIENT_SECRET")
    JWT_SECRET_KEY: str = os.getenv("JWT_SECRET_KEY", "")
    JWT_ALGORITHM: str = os.getenv("JWT_ALGORITHM", "HS256")
    ACCESS_TOKEN_EXPIRE_MINUTES: int = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", "30"))

    # Hosting
    DEPLOY_TARGET: str = os.getenv("HOSTING_TIER", "development")  # one of: development, railway, firebase, aws

    # Core FastAPI server settings
    SERVER_HOST: str = os.getenv("SERVER_HOST", "0.0.0.0")
    SERVER_PORT: int = int(os.getenv("SERVER_PORT", "8000"))

    # Logging
    LOG_LEVEL: str = os.getenv("LOG_LEVEL", "INFO")

    # Deployment-aware service URL
    @property
    def service_url(self) -> str:
        """
        Returns the base URL for external routing or monitoring,
        constructed based on DEPLOY_TARGET.
        """
        if self.DEPLOY_TARGET == "railway":
            return os.getenv("RAILWAY_SERVICE_URL", "")
        if self.DEPLOY_TARGET == "firebase":
            return os.getenv("FIREBASE_SERVICE_URL", "")
        if self.DEPLOY_TARGET == "aws":
            return os.getenv("AWS_API_GW_URL", "")
        if self.DEPLOY_TARGET == "supabase":
            return str(self.SUPABASE_URL or "")
        # development fallback
        return f"http://{self.SERVER_HOST}:{self.SERVER_PORT}"

    @validator("DEPLOY_TARGET")
    def validate_deploy_target(cls, v):
        allowed = {"development", "railway", "firebase", "aws", "supabase", "postgres"}
        if v not in allowed:
            raise ValueError(f"DEPLOY_TARGET must be one of {allowed}")
        return v

    RAILWAY_DATABASE_URL: AnyHttpUrl | None = os.getenv("RAILWAY_DATABASE_URL", None)
    FIREBASE_PROJECT_ID: str | None = os.getenv("FIREBASE_PROJECT_ID", None)
    AWS_REGION: str | None = os.getenv("AWS_REGION", None)
    AWS_LAMBDA_ROLE_ARN: str | None = os.getenv("AWS_LAMBDA_ROLE_ARN", None)

    @property
    def database_url(self) -> str | None:
        """
        Returns the primary database connection string or endpoint
        based on the configured hosting tier.
        """
        if self.DEPLOY_TARGET == "railway":
            return str(self.RAILWAY_DATABASE_URL)
        if self.DEPLOY_TARGET == "firebase":
            return f"https://firestore.googleapis.com/v1/projects/{self.FIREBASE_PROJECT_ID}/databases/(default)/documents"
        if self.DEPLOY_TARGET == "aws":
            # DynamoDB table endpoint can be constructed or use environment variable
            region = self.AWS_REGION or ""
            table = self.DYNAMODB_TABLE_NAME or ""
            return f"https://dynamodb.{region}.amazonaws.com/{table}"
        if self.DEPLOY_TARGET == "supabase":
            return str(self.SUPABASE_URL)
        if self.DEPLOY_TARGET == "postgres":
            return str(self.POSTGRES_URL)
        # development or fallback
        return None

    DYNAMODB_TABLE_NAME: str | None = os.getenv("DYNAMODB_TABLE_NAME", None)

    # Supabase settings
    SUPABASE_URL: AnyHttpUrl | None = os.getenv("SUPABASE_URL", None)
    SUPABASE_KEY: str | None = os.getenv("SUPABASE_KEY", None)

    # PostgreSQL settings (e.g., for Supabase or other Postgres hosts)
    POSTGRES_URL: AnyHttpUrl | None = os.getenv("POSTGRES_URL", None)

    # -----------------------------------------------------------------------------
    # Future Deploy Targets
    # Add new hosting platforms below following the pattern above.
    # -----------------------------------------------------------------------------

    @validator("VALID_API_KEYS", pre=True)
    def split_api_keys(cls, v):
        if isinstance(v, str):
            return [key.strip() for key in v.split(",") if key.strip()]
        return v

    @validator("PROD_CORS_ORIGINS", pre=True)
    def split_prod_origins(cls, v):
        if isinstance(v, str):
            return [origin.strip() for origin in v.split(",") if origin.strip()]
        return v

    @validator("DEV_CORS_ORIGINS", "CORS_ORIGINS", each_item=True)
    def validate_origins(cls, v):
        if not v:
            raise ValueError("CORS origin cannot be empty")
        return v

    @validator("MODULES_PATH", "DOCS_PATH", pre=True)
    def ensure_directory_exists(cls, v, field):
        import os
        if not os.path.isdir(v):
            try:
                os.makedirs(v, exist_ok=True)
            except Exception as e:
                raise ValueError(f"Unable to create directory for {field.name!r}: {e}")
        return v

    @validator("MKDOCS_CONFIG_PATH", pre=True)
    def validate_mkdocs_config_exists(cls, v):
        import os
        if not os.path.isfile(v):
            raise ValueError(f"MkDocs config file not found at path: {v}")
        return v

    class Config:
        env_file = ".env"

    @validator("MODULES_PATH", "DOCS_PATH", pre=True)
    def validate_paths_exist(cls, v, field):
        try:
            if not os.path.isdir(v):
                os.makedirs(v, exist_ok=True)
        except Exception as e:
            raise ValueError(f"Could not create {field.name} directory at {v}: {e}")
        return v

    @validator("MKDOCS_CONFIG_PATH", pre=True)
    def validate_mkdocs_config_exists(cls, v):
        if not os.path.isfile(v):
            raise ValueError(f"mkdocs config file not found at {v}")
        return v